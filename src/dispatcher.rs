//! Traits that decode RISC-V instructions and dispatch them to handlers.
//!

use crate::{
    cpu::{Rv32c, Rv32f, Rv32i, Rv32m},
    tobits::ToBits,
};

// This code was generated by `make_dispatcher.py`. Do not edit.

/// A dispatcher for RV32I instructions.
pub trait Rv32iDispatcher {
    type Item;

    /// Decodes the input word to an RV32I instruction and dispatches it to a handler.
    fn dispatch(&mut self, code: u32) -> <Self as Rv32i>::Item
    where
        Self: Rv32i;
}

impl<T, U> Rv32iDispatcher for T
where
    T: Rv32i + Rv32i<Item = U>,
{
    type Item = U;

    fn dispatch(&mut self, code: u32) -> Self::Item {
        #![allow(clippy::single_match)]

        let c = ToBits(code);

        match code {
            0x00000073 => return self.ecall(),
            0x00100073 => return self.ebreak(),
            _ => {}
        }
        match code & 0xfe00707f {
            0x00000033 => return self.add(c.rd(), c.rs1(), c.rs2()),
            0x40000033 => return self.sub(c.rd(), c.rs1(), c.rs2()),
            0x00001033 => return self.sll(c.rd(), c.rs1(), c.rs2()),
            0x00002033 => return self.slt(c.rd(), c.rs1(), c.rs2()),
            0x00003033 => return self.sltu(c.rd(), c.rs1(), c.rs2()),
            0x00004033 => return self.xor(c.rd(), c.rs1(), c.rs2()),
            0x00005033 => return self.srl(c.rd(), c.rs1(), c.rs2()),
            0x40005033 => return self.sra(c.rd(), c.rs1(), c.rs2()),
            0x00006033 => return self.or(c.rd(), c.rs1(), c.rs2()),
            0x00007033 => return self.and(c.rd(), c.rs1(), c.rs2()),
            0x00001013 => return self.slli(c.rd(), c.rs1(), c.shamtw()),
            0x00005013 => return self.srli(c.rd(), c.rs1(), c.shamtw()),
            0x40005013 => return self.srai(c.rd(), c.rs1(), c.shamtw()),
            _ => {}
        }
        match code & 0x0000707f {
            0x00000063 => return self.beq(c.rs1(), c.rs2(), c.bimmediate()),
            0x00001063 => return self.bne(c.rs1(), c.rs2(), c.bimmediate()),
            0x00004063 => return self.blt(c.rs1(), c.rs2(), c.bimmediate()),
            0x00005063 => return self.bge(c.rs1(), c.rs2(), c.bimmediate()),
            0x00006063 => return self.bltu(c.rs1(), c.rs2(), c.bimmediate()),
            0x00007063 => return self.bgeu(c.rs1(), c.rs2(), c.bimmediate()),
            0x00000067 => return self.jalr(c.rd(), c.rs1(), c.iimmediate()),
            0x00000013 => return self.addi(c.rd(), c.rs1(), c.iimmediate()),
            0x00002013 => return self.slti(c.rd(), c.rs1(), c.iimmediate()),
            0x00003013 => return self.sltiu(c.rd(), c.rs1(), c.iimmediate()),
            0x00004013 => return self.xori(c.rd(), c.rs1(), c.iimmediate()),
            0x00006013 => return self.ori(c.rd(), c.rs1(), c.iimmediate()),
            0x00007013 => return self.andi(c.rd(), c.rs1(), c.iimmediate()),
            0x00000003 => return self.lb(c.rd(), c.rs1(), c.iimmediate()),
            0x00001003 => return self.lh(c.rd(), c.rs1(), c.iimmediate()),
            0x00002003 => return self.lw(c.rd(), c.rs1(), c.iimmediate()),
            0x00004003 => return self.lbu(c.rd(), c.rs1(), c.iimmediate()),
            0x00005003 => return self.lhu(c.rd(), c.rs1(), c.iimmediate()),
            0x00000023 => return self.sb(c.rs1(), c.rs2(), c.simmediate()),
            0x00001023 => return self.sh(c.rs1(), c.rs2(), c.simmediate()),
            0x00002023 => return self.sw(c.rs1(), c.rs2(), c.simmediate()),
            0x0000000f => return self.fence(c.fm(), c.rd(), c.rs1()),
            _ => {}
        }
        match code & 0x0000007f {
            0x0000006f => return self.jal(c.rd(), c.jimmediate()),
            0x00000037 => return self.lui(c.rd(), c.uimmediate()),
            0x00000017 => return self.auipc(c.rd(), c.uimmediate()),
            _ => {}
        }
        self.illegal(code)
    }
}

// End of auto-generated code.

// This code was generated by `make_dispatcher.py -m`. Do not edit.

/// A dispatcher for RV32IM instructions.
pub trait Rv32imDispatcher {
    type Item;

    /// Decodes the input word to an RV32IM instruction and dispatches it to a handler.
    fn dispatch(&mut self, code: u32) -> <Self as Rv32i>::Item
    where
        Self: Rv32i + Rv32m;
}

impl<T, U> Rv32imDispatcher for T
where
    T: Rv32i + Rv32i<Item = U> + Rv32m + Rv32m<Item = U>,
{
    type Item = U;

    fn dispatch(&mut self, code: u32) -> Self::Item {
        #![allow(clippy::single_match)]

        let c = ToBits(code);

        match code {
            0x00000073 => return self.ecall(),
            0x00100073 => return self.ebreak(),
            _ => {}
        }
        match code & 0xfe00707f {
            0x00000033 => return self.add(c.rd(), c.rs1(), c.rs2()),
            0x40000033 => return self.sub(c.rd(), c.rs1(), c.rs2()),
            0x00001033 => return self.sll(c.rd(), c.rs1(), c.rs2()),
            0x00002033 => return self.slt(c.rd(), c.rs1(), c.rs2()),
            0x00003033 => return self.sltu(c.rd(), c.rs1(), c.rs2()),
            0x00004033 => return self.xor(c.rd(), c.rs1(), c.rs2()),
            0x00005033 => return self.srl(c.rd(), c.rs1(), c.rs2()),
            0x40005033 => return self.sra(c.rd(), c.rs1(), c.rs2()),
            0x00006033 => return self.or(c.rd(), c.rs1(), c.rs2()),
            0x00007033 => return self.and(c.rd(), c.rs1(), c.rs2()),
            0x00001013 => return self.slli(c.rd(), c.rs1(), c.shamtw()),
            0x00005013 => return self.srli(c.rd(), c.rs1(), c.shamtw()),
            0x40005013 => return self.srai(c.rd(), c.rs1(), c.shamtw()),
            0x02000033 => return self.mul(c.rd(), c.rs1(), c.rs2()),
            0x02001033 => return self.mulh(c.rd(), c.rs1(), c.rs2()),
            0x02002033 => return self.mulhsu(c.rd(), c.rs1(), c.rs2()),
            0x02003033 => return self.mulhu(c.rd(), c.rs1(), c.rs2()),
            0x02004033 => return self.div(c.rd(), c.rs1(), c.rs2()),
            0x02005033 => return self.divu(c.rd(), c.rs1(), c.rs2()),
            0x02006033 => return self.rem(c.rd(), c.rs1(), c.rs2()),
            0x02007033 => return self.remu(c.rd(), c.rs1(), c.rs2()),
            _ => {}
        }
        match code & 0x0000707f {
            0x00000063 => return self.beq(c.rs1(), c.rs2(), c.bimmediate()),
            0x00001063 => return self.bne(c.rs1(), c.rs2(), c.bimmediate()),
            0x00004063 => return self.blt(c.rs1(), c.rs2(), c.bimmediate()),
            0x00005063 => return self.bge(c.rs1(), c.rs2(), c.bimmediate()),
            0x00006063 => return self.bltu(c.rs1(), c.rs2(), c.bimmediate()),
            0x00007063 => return self.bgeu(c.rs1(), c.rs2(), c.bimmediate()),
            0x00000067 => return self.jalr(c.rd(), c.rs1(), c.iimmediate()),
            0x00000013 => return self.addi(c.rd(), c.rs1(), c.iimmediate()),
            0x00002013 => return self.slti(c.rd(), c.rs1(), c.iimmediate()),
            0x00003013 => return self.sltiu(c.rd(), c.rs1(), c.iimmediate()),
            0x00004013 => return self.xori(c.rd(), c.rs1(), c.iimmediate()),
            0x00006013 => return self.ori(c.rd(), c.rs1(), c.iimmediate()),
            0x00007013 => return self.andi(c.rd(), c.rs1(), c.iimmediate()),
            0x00000003 => return self.lb(c.rd(), c.rs1(), c.iimmediate()),
            0x00001003 => return self.lh(c.rd(), c.rs1(), c.iimmediate()),
            0x00002003 => return self.lw(c.rd(), c.rs1(), c.iimmediate()),
            0x00004003 => return self.lbu(c.rd(), c.rs1(), c.iimmediate()),
            0x00005003 => return self.lhu(c.rd(), c.rs1(), c.iimmediate()),
            0x00000023 => return self.sb(c.rs1(), c.rs2(), c.simmediate()),
            0x00001023 => return self.sh(c.rs1(), c.rs2(), c.simmediate()),
            0x00002023 => return self.sw(c.rs1(), c.rs2(), c.simmediate()),
            0x0000000f => return self.fence(c.fm(), c.rd(), c.rs1()),
            _ => {}
        }
        match code & 0x0000007f {
            0x0000006f => return self.jal(c.rd(), c.jimmediate()),
            0x00000037 => return self.lui(c.rd(), c.uimmediate()),
            0x00000017 => return self.auipc(c.rd(), c.uimmediate()),
            _ => {}
        }
        self.illegal(code)
    }
}

// End of auto-generated code.

// This code was generated by `make_dispatcher.py -c`. Do not edit.

/// A dispatcher for RV32IC instructions.
pub trait Rv32icDispatcher {
    type Item;

    /// Decodes the input word to an RV32IC instruction and dispatches it to a handler.
    fn dispatch(&mut self, code: u32) -> <Self as Rv32i>::Item
    where
        Self: Rv32i + Rv32c;
}

impl<T, U> Rv32icDispatcher for T
where
    T: Rv32i + Rv32i<Item = U> + Rv32c + Rv32c<Item = U>,
{
    type Item = U;

    fn dispatch(&mut self, code: u32) -> Self::Item {
        #![allow(clippy::single_match)]

        let c = ToBits(code);

        match code {
            0x00000073 => return self.ecall(),
            0x00100073 => return self.ebreak(),
            _ => {}
        }
        match code & 0xfe00707f {
            0x00000033 => return self.add(c.rd(), c.rs1(), c.rs2()),
            0x40000033 => return self.sub(c.rd(), c.rs1(), c.rs2()),
            0x00001033 => return self.sll(c.rd(), c.rs1(), c.rs2()),
            0x00002033 => return self.slt(c.rd(), c.rs1(), c.rs2()),
            0x00003033 => return self.sltu(c.rd(), c.rs1(), c.rs2()),
            0x00004033 => return self.xor(c.rd(), c.rs1(), c.rs2()),
            0x00005033 => return self.srl(c.rd(), c.rs1(), c.rs2()),
            0x40005033 => return self.sra(c.rd(), c.rs1(), c.rs2()),
            0x00006033 => return self.or(c.rd(), c.rs1(), c.rs2()),
            0x00007033 => return self.and(c.rd(), c.rs1(), c.rs2()),
            0x00001013 => return self.slli(c.rd(), c.rs1(), c.shamtw()),
            0x00005013 => return self.srli(c.rd(), c.rs1(), c.shamtw()),
            0x40005013 => return self.srai(c.rd(), c.rs1(), c.shamtw()),
            _ => {}
        }
        match code & 0x0000ffff {
            0x9002 => return self.c_ebreak(),
            _ => {}
        }
        match code & 0x0000f07f {
            0x8002 => return self.c_jr(c.rs1n0()),
            0x9002 => return self.c_jalr(c.rs1n0()),
            _ => {}
        }
        match code & 0x0000707f {
            0x00000063 => return self.beq(c.rs1(), c.rs2(), c.bimmediate()),
            0x00001063 => return self.bne(c.rs1(), c.rs2(), c.bimmediate()),
            0x00004063 => return self.blt(c.rs1(), c.rs2(), c.bimmediate()),
            0x00005063 => return self.bge(c.rs1(), c.rs2(), c.bimmediate()),
            0x00006063 => return self.bltu(c.rs1(), c.rs2(), c.bimmediate()),
            0x00007063 => return self.bgeu(c.rs1(), c.rs2(), c.bimmediate()),
            0x00000067 => return self.jalr(c.rd(), c.rs1(), c.iimmediate()),
            0x00000013 => return self.addi(c.rd(), c.rs1(), c.iimmediate()),
            0x00002013 => return self.slti(c.rd(), c.rs1(), c.iimmediate()),
            0x00003013 => return self.sltiu(c.rd(), c.rs1(), c.iimmediate()),
            0x00004013 => return self.xori(c.rd(), c.rs1(), c.iimmediate()),
            0x00006013 => return self.ori(c.rd(), c.rs1(), c.iimmediate()),
            0x00007013 => return self.andi(c.rd(), c.rs1(), c.iimmediate()),
            0x00000003 => return self.lb(c.rd(), c.rs1(), c.iimmediate()),
            0x00001003 => return self.lh(c.rd(), c.rs1(), c.iimmediate()),
            0x00002003 => return self.lw(c.rd(), c.rs1(), c.iimmediate()),
            0x00004003 => return self.lbu(c.rd(), c.rs1(), c.iimmediate()),
            0x00005003 => return self.lhu(c.rd(), c.rs1(), c.iimmediate()),
            0x00000023 => return self.sb(c.rs1(), c.rs2(), c.simmediate()),
            0x00001023 => return self.sh(c.rs1(), c.rs2(), c.simmediate()),
            0x00002023 => return self.sw(c.rs1(), c.rs2(), c.simmediate()),
            0x0000000f => return self.fence(c.fm(), c.rd(), c.rs1()),
            _ => {}
        }
        match code & 0x0000ef83 {
            0x0001 => return self.c_nop(c.c_nzimm6()),
            0x6101 => return self.c_addi16sp(c.c_nzimm10()),
            _ => {}
        }
        match code & 0x0000fc63 {
            0x8c01 => return self.c_sub(c.rdrs1p(), c.rs2p()),
            0x8c21 => return self.c_xor(c.rdrs1p(), c.rs2p()),
            0x8c41 => return self.c_or(c.rdrs1p(), c.rs2p()),
            0x8c61 => return self.c_and(c.rdrs1p(), c.rs2p()),
            _ => {}
        }
        match code & 0x0000007f {
            0x0000006f => return self.jal(c.rd(), c.jimmediate()),
            0x00000037 => return self.lui(c.rd(), c.uimmediate()),
            0x00000017 => return self.auipc(c.rd(), c.uimmediate()),
            _ => {}
        }
        match code & 0x0000ec03 {
            0x8801 => return self.c_andi(c.rdrs1p(), c.c_imm6()),
            0x8001 => return self.c_srli(c.rdrs1p(), c.c_nzuimm6()),
            0x8401 => return self.c_srai(c.rdrs1p(), c.c_nzuimm6()),
            _ => {}
        }
        match code & 0x0000f003 {
            0x8002 => return self.c_mv(c.rd(), c.rs2n0()),
            0x9002 => return self.c_add(c.rdrs1(), c.rs2n0()),
            _ => {}
        }
        match code & 0x0000e003 {
            0x0000 => return self.c_addi4spn(c.rdp(), c.c_nzuimm10()),
            0x4000 => return self.c_lw(c.rdp(), c.rs1p(), c.c_uimm7()),
            0xc000 => return self.c_sw(c.rs1p(), c.rs2p(), c.c_uimm7()),
            0x0001 => return self.c_addi(c.rdrs1n0(), c.c_nzimm6()),
            0x4001 => return self.c_li(c.rd(), c.c_imm6()),
            0x6001 => return self.c_lui(c.rdn2(), c.c_nzimm18()),
            0xa001 => return self.c_j(c.c_imm12()),
            0xc001 => return self.c_beqz(c.rs1p(), c.c_bimm9()),
            0xe001 => return self.c_bnez(c.rs1p(), c.c_bimm9()),
            0x4002 => return self.c_lwsp(c.rdn0(), c.c_uimm8sp()),
            0xc002 => return self.c_swsp(c.c_rs2(), c.c_uimm8sp_s()),
            0x2001 => return self.c_jal(c.c_imm12()),
            0x0002 => return self.c_slli(c.rdrs1n0(), c.c_nzuimm6()),
            _ => {}
        }
        self.illegal(code)
    }
}

// End of auto-generated code.

// This code was generated by `make_dispatcher.py -mc`. Do not edit.

/// A dispatcher for RV32IMC instructions.
pub trait Rv32imcDispatcher {
    type Item;

    /// Decodes the input word to an RV32IMC instruction and dispatches it to a handler.
    fn dispatch(&mut self, code: u32) -> <Self as Rv32i>::Item
    where
        Self: Rv32i + Rv32m + Rv32c;
}

impl<T, U> Rv32imcDispatcher for T
where
    T: Rv32i + Rv32i<Item = U> + Rv32m + Rv32m<Item = U> + Rv32c + Rv32c<Item = U>,
{
    type Item = U;

    fn dispatch(&mut self, code: u32) -> Self::Item {
        #![allow(clippy::single_match)]

        let c = ToBits(code);

        match code {
            0x00000073 => return self.ecall(),
            0x00100073 => return self.ebreak(),
            _ => {}
        }
        match code & 0xfe00707f {
            0x00000033 => return self.add(c.rd(), c.rs1(), c.rs2()),
            0x40000033 => return self.sub(c.rd(), c.rs1(), c.rs2()),
            0x00001033 => return self.sll(c.rd(), c.rs1(), c.rs2()),
            0x00002033 => return self.slt(c.rd(), c.rs1(), c.rs2()),
            0x00003033 => return self.sltu(c.rd(), c.rs1(), c.rs2()),
            0x00004033 => return self.xor(c.rd(), c.rs1(), c.rs2()),
            0x00005033 => return self.srl(c.rd(), c.rs1(), c.rs2()),
            0x40005033 => return self.sra(c.rd(), c.rs1(), c.rs2()),
            0x00006033 => return self.or(c.rd(), c.rs1(), c.rs2()),
            0x00007033 => return self.and(c.rd(), c.rs1(), c.rs2()),
            0x00001013 => return self.slli(c.rd(), c.rs1(), c.shamtw()),
            0x00005013 => return self.srli(c.rd(), c.rs1(), c.shamtw()),
            0x40005013 => return self.srai(c.rd(), c.rs1(), c.shamtw()),
            0x02000033 => return self.mul(c.rd(), c.rs1(), c.rs2()),
            0x02001033 => return self.mulh(c.rd(), c.rs1(), c.rs2()),
            0x02002033 => return self.mulhsu(c.rd(), c.rs1(), c.rs2()),
            0x02003033 => return self.mulhu(c.rd(), c.rs1(), c.rs2()),
            0x02004033 => return self.div(c.rd(), c.rs1(), c.rs2()),
            0x02005033 => return self.divu(c.rd(), c.rs1(), c.rs2()),
            0x02006033 => return self.rem(c.rd(), c.rs1(), c.rs2()),
            0x02007033 => return self.remu(c.rd(), c.rs1(), c.rs2()),
            _ => {}
        }
        match code & 0x0000ffff {
            0x9002 => return self.c_ebreak(),
            _ => {}
        }
        match code & 0x0000f07f {
            0x8002 => return self.c_jr(c.rs1n0()),
            0x9002 => return self.c_jalr(c.rs1n0()),
            _ => {}
        }
        match code & 0x0000707f {
            0x00000063 => return self.beq(c.rs1(), c.rs2(), c.bimmediate()),
            0x00001063 => return self.bne(c.rs1(), c.rs2(), c.bimmediate()),
            0x00004063 => return self.blt(c.rs1(), c.rs2(), c.bimmediate()),
            0x00005063 => return self.bge(c.rs1(), c.rs2(), c.bimmediate()),
            0x00006063 => return self.bltu(c.rs1(), c.rs2(), c.bimmediate()),
            0x00007063 => return self.bgeu(c.rs1(), c.rs2(), c.bimmediate()),
            0x00000067 => return self.jalr(c.rd(), c.rs1(), c.iimmediate()),
            0x00000013 => return self.addi(c.rd(), c.rs1(), c.iimmediate()),
            0x00002013 => return self.slti(c.rd(), c.rs1(), c.iimmediate()),
            0x00003013 => return self.sltiu(c.rd(), c.rs1(), c.iimmediate()),
            0x00004013 => return self.xori(c.rd(), c.rs1(), c.iimmediate()),
            0x00006013 => return self.ori(c.rd(), c.rs1(), c.iimmediate()),
            0x00007013 => return self.andi(c.rd(), c.rs1(), c.iimmediate()),
            0x00000003 => return self.lb(c.rd(), c.rs1(), c.iimmediate()),
            0x00001003 => return self.lh(c.rd(), c.rs1(), c.iimmediate()),
            0x00002003 => return self.lw(c.rd(), c.rs1(), c.iimmediate()),
            0x00004003 => return self.lbu(c.rd(), c.rs1(), c.iimmediate()),
            0x00005003 => return self.lhu(c.rd(), c.rs1(), c.iimmediate()),
            0x00000023 => return self.sb(c.rs1(), c.rs2(), c.simmediate()),
            0x00001023 => return self.sh(c.rs1(), c.rs2(), c.simmediate()),
            0x00002023 => return self.sw(c.rs1(), c.rs2(), c.simmediate()),
            0x0000000f => return self.fence(c.fm(), c.rd(), c.rs1()),
            _ => {}
        }
        match code & 0x0000ef83 {
            0x0001 => return self.c_nop(c.c_nzimm6()),
            0x6101 => return self.c_addi16sp(c.c_nzimm10()),
            _ => {}
        }
        match code & 0x0000fc63 {
            0x8c01 => return self.c_sub(c.rdrs1p(), c.rs2p()),
            0x8c21 => return self.c_xor(c.rdrs1p(), c.rs2p()),
            0x8c41 => return self.c_or(c.rdrs1p(), c.rs2p()),
            0x8c61 => return self.c_and(c.rdrs1p(), c.rs2p()),
            _ => {}
        }
        match code & 0x0000007f {
            0x0000006f => return self.jal(c.rd(), c.jimmediate()),
            0x00000037 => return self.lui(c.rd(), c.uimmediate()),
            0x00000017 => return self.auipc(c.rd(), c.uimmediate()),
            _ => {}
        }
        match code & 0x0000ec03 {
            0x8801 => return self.c_andi(c.rdrs1p(), c.c_imm6()),
            0x8001 => return self.c_srli(c.rdrs1p(), c.c_nzuimm6()),
            0x8401 => return self.c_srai(c.rdrs1p(), c.c_nzuimm6()),
            _ => {}
        }
        match code & 0x0000f003 {
            0x8002 => return self.c_mv(c.rd(), c.rs2n0()),
            0x9002 => return self.c_add(c.rdrs1(), c.rs2n0()),
            _ => {}
        }
        match code & 0x0000e003 {
            0x0000 => return self.c_addi4spn(c.rdp(), c.c_nzuimm10()),
            0x4000 => return self.c_lw(c.rdp(), c.rs1p(), c.c_uimm7()),
            0xc000 => return self.c_sw(c.rs1p(), c.rs2p(), c.c_uimm7()),
            0x0001 => return self.c_addi(c.rdrs1n0(), c.c_nzimm6()),
            0x4001 => return self.c_li(c.rd(), c.c_imm6()),
            0x6001 => return self.c_lui(c.rdn2(), c.c_nzimm18()),
            0xa001 => return self.c_j(c.c_imm12()),
            0xc001 => return self.c_beqz(c.rs1p(), c.c_bimm9()),
            0xe001 => return self.c_bnez(c.rs1p(), c.c_bimm9()),
            0x4002 => return self.c_lwsp(c.rdn0(), c.c_uimm8sp()),
            0xc002 => return self.c_swsp(c.c_rs2(), c.c_uimm8sp_s()),
            0x2001 => return self.c_jal(c.c_imm12()),
            0x0002 => return self.c_slli(c.rdrs1n0(), c.c_nzuimm6()),
            _ => {}
        }
        self.illegal(code)
    }
}

// End of auto-generated code.

// This code was generated by `make_dispatcher.py -mf`. Do not edit.

/// A dispatcher for RV32IMF instructions.
pub trait Rv32imfDispatcher {
    type Item;

    /// Decodes the input word to an RV32IMF instruction and dispatches it to a handler.
    fn dispatch(&mut self, code: u32) -> <Self as Rv32i>::Item
    where
        Self: Rv32i + Rv32m + Rv32f;
}

impl<T, U> Rv32imfDispatcher for T
where
    T: Rv32i + Rv32i<Item = U> + Rv32m + Rv32m<Item = U> + Rv32f + Rv32f<Item = U>,
{
    type Item = U;

    fn dispatch(&mut self, code: u32) -> Self::Item {
        #![allow(clippy::single_match)]

        let c = ToBits(code);

        match code {
            0x00000073 => return self.ecall(),
            0x00100073 => return self.ebreak(),
            _ => {}
        }
        match code & 0xfff0707f {
            0xe0000053 => return self.fmv_x_w(c.rd(), c.rs1()),
            0xe0001053 => return self.fclass_s(c.rd(), c.rs1()),
            0xf0000053 => return self.fmv_w_x(c.rd(), c.rs1()),
            _ => {}
        }
        match code & 0xfff0007f {
            0x58000053 => return self.fsqrt_s(c.rd(), c.rs1(), c.rm()),
            0xc0000053 => return self.fcvt_w_s(c.rd(), c.rs1(), c.rm()),
            0xc0100053 => return self.fcvt_wu_s(c.rd(), c.rs1(), c.rm()),
            0xd0000053 => return self.fcvt_s_w(c.rd(), c.rs1(), c.rm()),
            0xd0100053 => return self.fcvt_s_wu(c.rd(), c.rs1(), c.rm()),
            _ => {}
        }
        match code & 0xfe00707f {
            0x00000033 => return self.add(c.rd(), c.rs1(), c.rs2()),
            0x40000033 => return self.sub(c.rd(), c.rs1(), c.rs2()),
            0x00001033 => return self.sll(c.rd(), c.rs1(), c.rs2()),
            0x00002033 => return self.slt(c.rd(), c.rs1(), c.rs2()),
            0x00003033 => return self.sltu(c.rd(), c.rs1(), c.rs2()),
            0x00004033 => return self.xor(c.rd(), c.rs1(), c.rs2()),
            0x00005033 => return self.srl(c.rd(), c.rs1(), c.rs2()),
            0x40005033 => return self.sra(c.rd(), c.rs1(), c.rs2()),
            0x00006033 => return self.or(c.rd(), c.rs1(), c.rs2()),
            0x00007033 => return self.and(c.rd(), c.rs1(), c.rs2()),
            0x00001013 => return self.slli(c.rd(), c.rs1(), c.shamtw()),
            0x00005013 => return self.srli(c.rd(), c.rs1(), c.shamtw()),
            0x40005013 => return self.srai(c.rd(), c.rs1(), c.shamtw()),
            0x02000033 => return self.mul(c.rd(), c.rs1(), c.rs2()),
            0x02001033 => return self.mulh(c.rd(), c.rs1(), c.rs2()),
            0x02002033 => return self.mulhsu(c.rd(), c.rs1(), c.rs2()),
            0x02003033 => return self.mulhu(c.rd(), c.rs1(), c.rs2()),
            0x02004033 => return self.div(c.rd(), c.rs1(), c.rs2()),
            0x02005033 => return self.divu(c.rd(), c.rs1(), c.rs2()),
            0x02006033 => return self.rem(c.rd(), c.rs1(), c.rs2()),
            0x02007033 => return self.remu(c.rd(), c.rs1(), c.rs2()),
            _ => {}
        }
        match code & 0xfe00707f {
            0x20000053 => return self.fsgnj_s(c.rd(), c.rs1(), c.rs2()),
            0x20001053 => return self.fsgnjn_s(c.rd(), c.rs1(), c.rs2()),
            0x20002053 => return self.fsgnjx_s(c.rd(), c.rs1(), c.rs2()),
            0x28000053 => return self.fmin_s(c.rd(), c.rs1(), c.rs2()),
            0x28001053 => return self.fmax_s(c.rd(), c.rs1(), c.rs2()),
            0xa0000053 => return self.fle_s(c.rd(), c.rs1(), c.rs2()),
            0xa0001053 => return self.flt_s(c.rd(), c.rs1(), c.rs2()),
            0xa0002053 => return self.feq_s(c.rd(), c.rs1(), c.rs2()),
            _ => {}
        }
        match code & 0xfe00007f {
            0x00000053 => return self.fadd_s(c.rd(), c.rs1(), c.rs2(), c.rm()),
            0x08000053 => return self.fsub_s(c.rd(), c.rs1(), c.rs2(), c.rm()),
            0x10000053 => return self.fmul_s(c.rd(), c.rs1(), c.rs2(), c.rm()),
            0x18000053 => return self.fdiv_s(c.rd(), c.rs1(), c.rs2(), c.rm()),
            _ => {}
        }
        match code & 0x0000707f {
            0x00000063 => return self.beq(c.rs1(), c.rs2(), c.bimmediate()),
            0x00001063 => return self.bne(c.rs1(), c.rs2(), c.bimmediate()),
            0x00004063 => return self.blt(c.rs1(), c.rs2(), c.bimmediate()),
            0x00005063 => return self.bge(c.rs1(), c.rs2(), c.bimmediate()),
            0x00006063 => return self.bltu(c.rs1(), c.rs2(), c.bimmediate()),
            0x00007063 => return self.bgeu(c.rs1(), c.rs2(), c.bimmediate()),
            0x00000067 => return self.jalr(c.rd(), c.rs1(), c.iimmediate()),
            0x00000013 => return self.addi(c.rd(), c.rs1(), c.iimmediate()),
            0x00002013 => return self.slti(c.rd(), c.rs1(), c.iimmediate()),
            0x00003013 => return self.sltiu(c.rd(), c.rs1(), c.iimmediate()),
            0x00004013 => return self.xori(c.rd(), c.rs1(), c.iimmediate()),
            0x00006013 => return self.ori(c.rd(), c.rs1(), c.iimmediate()),
            0x00007013 => return self.andi(c.rd(), c.rs1(), c.iimmediate()),
            0x00000003 => return self.lb(c.rd(), c.rs1(), c.iimmediate()),
            0x00001003 => return self.lh(c.rd(), c.rs1(), c.iimmediate()),
            0x00002003 => return self.lw(c.rd(), c.rs1(), c.iimmediate()),
            0x00004003 => return self.lbu(c.rd(), c.rs1(), c.iimmediate()),
            0x00005003 => return self.lhu(c.rd(), c.rs1(), c.iimmediate()),
            0x00000023 => return self.sb(c.rs1(), c.rs2(), c.simmediate()),
            0x00001023 => return self.sh(c.rs1(), c.rs2(), c.simmediate()),
            0x00002023 => return self.sw(c.rs1(), c.rs2(), c.simmediate()),
            0x0000000f => return self.fence(c.fm(), c.rd(), c.rs1()),
            0x00002007 => return self.flw(c.rd(), c.rs1(), c.iimmediate()),
            0x00002027 => return self.fsw(c.rs1(), c.rs2(), c.simmediate()),
            _ => {}
        }
        match code & 0x0600007f {
            0x00000043 => return self.fmadd_s(c.rd(), c.rs1(), c.rs2(), c.rs3(), c.rm()),
            0x00000047 => return self.fmsub_s(c.rd(), c.rs1(), c.rs2(), c.rs3(), c.rm()),
            0x0000004b => return self.fnmsub_s(c.rd(), c.rs1(), c.rs2(), c.rs3(), c.rm()),
            0x0000004f => return self.fnmadd_s(c.rd(), c.rs1(), c.rs2(), c.rs3(), c.rm()),
            _ => {}
        }
        match code & 0x0000007f {
            0x0000006f => return self.jal(c.rd(), c.jimmediate()),
            0x00000037 => return self.lui(c.rd(), c.uimmediate()),
            0x00000017 => return self.auipc(c.rd(), c.uimmediate()),
            _ => {}
        }
        self.illegal(code)
    }
}

// End of auto-generated code.

// This code was generated by `make_dispatcher.py -mfc`. Do not edit.

/// A dispatcher for RV32IMFC instructions.
pub trait Rv32imfcDispatcher {
    type Item;

    /// Decodes the input word to an RV32IMFC instruction and dispatches it to a handler.
    fn dispatch(&mut self, code: u32) -> <Self as Rv32i>::Item
    where
        Self: Rv32i + Rv32m + Rv32f + Rv32c;
}

impl<T, U> Rv32imfcDispatcher for T
where
    T: Rv32i
        + Rv32i<Item = U>
        + Rv32m
        + Rv32m<Item = U>
        + Rv32f
        + Rv32f<Item = U>
        + Rv32c
        + Rv32c<Item = U>,
{
    type Item = U;

    fn dispatch(&mut self, code: u32) -> Self::Item {
        #![allow(clippy::single_match)]

        let c = ToBits(code);

        match code {
            0x00000073 => return self.ecall(),
            0x00100073 => return self.ebreak(),
            _ => {}
        }
        match code & 0xfff0707f {
            0xe0000053 => return self.fmv_x_w(c.rd(), c.rs1()),
            0xe0001053 => return self.fclass_s(c.rd(), c.rs1()),
            0xf0000053 => return self.fmv_w_x(c.rd(), c.rs1()),
            _ => {}
        }
        match code & 0xfff0007f {
            0x58000053 => return self.fsqrt_s(c.rd(), c.rs1(), c.rm()),
            0xc0000053 => return self.fcvt_w_s(c.rd(), c.rs1(), c.rm()),
            0xc0100053 => return self.fcvt_wu_s(c.rd(), c.rs1(), c.rm()),
            0xd0000053 => return self.fcvt_s_w(c.rd(), c.rs1(), c.rm()),
            0xd0100053 => return self.fcvt_s_wu(c.rd(), c.rs1(), c.rm()),
            _ => {}
        }
        match code & 0xfe00707f {
            0x00000033 => return self.add(c.rd(), c.rs1(), c.rs2()),
            0x40000033 => return self.sub(c.rd(), c.rs1(), c.rs2()),
            0x00001033 => return self.sll(c.rd(), c.rs1(), c.rs2()),
            0x00002033 => return self.slt(c.rd(), c.rs1(), c.rs2()),
            0x00003033 => return self.sltu(c.rd(), c.rs1(), c.rs2()),
            0x00004033 => return self.xor(c.rd(), c.rs1(), c.rs2()),
            0x00005033 => return self.srl(c.rd(), c.rs1(), c.rs2()),
            0x40005033 => return self.sra(c.rd(), c.rs1(), c.rs2()),
            0x00006033 => return self.or(c.rd(), c.rs1(), c.rs2()),
            0x00007033 => return self.and(c.rd(), c.rs1(), c.rs2()),
            0x00001013 => return self.slli(c.rd(), c.rs1(), c.shamtw()),
            0x00005013 => return self.srli(c.rd(), c.rs1(), c.shamtw()),
            0x40005013 => return self.srai(c.rd(), c.rs1(), c.shamtw()),
            0x02000033 => return self.mul(c.rd(), c.rs1(), c.rs2()),
            0x02001033 => return self.mulh(c.rd(), c.rs1(), c.rs2()),
            0x02002033 => return self.mulhsu(c.rd(), c.rs1(), c.rs2()),
            0x02003033 => return self.mulhu(c.rd(), c.rs1(), c.rs2()),
            0x02004033 => return self.div(c.rd(), c.rs1(), c.rs2()),
            0x02005033 => return self.divu(c.rd(), c.rs1(), c.rs2()),
            0x02006033 => return self.rem(c.rd(), c.rs1(), c.rs2()),
            0x02007033 => return self.remu(c.rd(), c.rs1(), c.rs2()),
            _ => {}
        }
        match code & 0xfe00707f {
            0x20000053 => return self.fsgnj_s(c.rd(), c.rs1(), c.rs2()),
            0x20001053 => return self.fsgnjn_s(c.rd(), c.rs1(), c.rs2()),
            0x20002053 => return self.fsgnjx_s(c.rd(), c.rs1(), c.rs2()),
            0x28000053 => return self.fmin_s(c.rd(), c.rs1(), c.rs2()),
            0x28001053 => return self.fmax_s(c.rd(), c.rs1(), c.rs2()),
            0xa0000053 => return self.fle_s(c.rd(), c.rs1(), c.rs2()),
            0xa0001053 => return self.flt_s(c.rd(), c.rs1(), c.rs2()),
            0xa0002053 => return self.feq_s(c.rd(), c.rs1(), c.rs2()),
            _ => {}
        }
        match code & 0x0000ffff {
            0x9002 => return self.c_ebreak(),
            _ => {}
        }
        match code & 0xfe00007f {
            0x00000053 => return self.fadd_s(c.rd(), c.rs1(), c.rs2(), c.rm()),
            0x08000053 => return self.fsub_s(c.rd(), c.rs1(), c.rs2(), c.rm()),
            0x10000053 => return self.fmul_s(c.rd(), c.rs1(), c.rs2(), c.rm()),
            0x18000053 => return self.fdiv_s(c.rd(), c.rs1(), c.rs2(), c.rm()),
            _ => {}
        }
        match code & 0x0000f07f {
            0x8002 => return self.c_jr(c.rs1n0()),
            0x9002 => return self.c_jalr(c.rs1n0()),
            _ => {}
        }
        match code & 0x0000707f {
            0x00000063 => return self.beq(c.rs1(), c.rs2(), c.bimmediate()),
            0x00001063 => return self.bne(c.rs1(), c.rs2(), c.bimmediate()),
            0x00004063 => return self.blt(c.rs1(), c.rs2(), c.bimmediate()),
            0x00005063 => return self.bge(c.rs1(), c.rs2(), c.bimmediate()),
            0x00006063 => return self.bltu(c.rs1(), c.rs2(), c.bimmediate()),
            0x00007063 => return self.bgeu(c.rs1(), c.rs2(), c.bimmediate()),
            0x00000067 => return self.jalr(c.rd(), c.rs1(), c.iimmediate()),
            0x00000013 => return self.addi(c.rd(), c.rs1(), c.iimmediate()),
            0x00002013 => return self.slti(c.rd(), c.rs1(), c.iimmediate()),
            0x00003013 => return self.sltiu(c.rd(), c.rs1(), c.iimmediate()),
            0x00004013 => return self.xori(c.rd(), c.rs1(), c.iimmediate()),
            0x00006013 => return self.ori(c.rd(), c.rs1(), c.iimmediate()),
            0x00007013 => return self.andi(c.rd(), c.rs1(), c.iimmediate()),
            0x00000003 => return self.lb(c.rd(), c.rs1(), c.iimmediate()),
            0x00001003 => return self.lh(c.rd(), c.rs1(), c.iimmediate()),
            0x00002003 => return self.lw(c.rd(), c.rs1(), c.iimmediate()),
            0x00004003 => return self.lbu(c.rd(), c.rs1(), c.iimmediate()),
            0x00005003 => return self.lhu(c.rd(), c.rs1(), c.iimmediate()),
            0x00000023 => return self.sb(c.rs1(), c.rs2(), c.simmediate()),
            0x00001023 => return self.sh(c.rs1(), c.rs2(), c.simmediate()),
            0x00002023 => return self.sw(c.rs1(), c.rs2(), c.simmediate()),
            0x0000000f => return self.fence(c.fm(), c.rd(), c.rs1()),
            0x00002007 => return self.flw(c.rd(), c.rs1(), c.iimmediate()),
            0x00002027 => return self.fsw(c.rs1(), c.rs2(), c.simmediate()),
            _ => {}
        }
        match code & 0x0000ef83 {
            0x0001 => return self.c_nop(c.c_nzimm6()),
            0x6101 => return self.c_addi16sp(c.c_nzimm10()),
            _ => {}
        }
        match code & 0x0000fc63 {
            0x8c01 => return self.c_sub(c.rdrs1p(), c.rs2p()),
            0x8c21 => return self.c_xor(c.rdrs1p(), c.rs2p()),
            0x8c41 => return self.c_or(c.rdrs1p(), c.rs2p()),
            0x8c61 => return self.c_and(c.rdrs1p(), c.rs2p()),
            _ => {}
        }
        match code & 0x0600007f {
            0x00000043 => return self.fmadd_s(c.rd(), c.rs1(), c.rs2(), c.rs3(), c.rm()),
            0x00000047 => return self.fmsub_s(c.rd(), c.rs1(), c.rs2(), c.rs3(), c.rm()),
            0x0000004b => return self.fnmsub_s(c.rd(), c.rs1(), c.rs2(), c.rs3(), c.rm()),
            0x0000004f => return self.fnmadd_s(c.rd(), c.rs1(), c.rs2(), c.rs3(), c.rm()),
            _ => {}
        }
        match code & 0x0000007f {
            0x0000006f => return self.jal(c.rd(), c.jimmediate()),
            0x00000037 => return self.lui(c.rd(), c.uimmediate()),
            0x00000017 => return self.auipc(c.rd(), c.uimmediate()),
            _ => {}
        }
        match code & 0x0000ec03 {
            0x8801 => return self.c_andi(c.rdrs1p(), c.c_imm6()),
            0x8001 => return self.c_srli(c.rdrs1p(), c.c_nzuimm6()),
            0x8401 => return self.c_srai(c.rdrs1p(), c.c_nzuimm6()),
            _ => {}
        }
        match code & 0x0000f003 {
            0x8002 => return self.c_mv(c.rd(), c.rs2n0()),
            0x9002 => return self.c_add(c.rdrs1(), c.rs2n0()),
            _ => {}
        }
        match code & 0x0000e003 {
            0x0000 => return self.c_addi4spn(c.rdp(), c.c_nzuimm10()),
            0x4000 => return self.c_lw(c.rdp(), c.rs1p(), c.c_uimm7()),
            0xc000 => return self.c_sw(c.rs1p(), c.rs2p(), c.c_uimm7()),
            0x0001 => return self.c_addi(c.rdrs1n0(), c.c_nzimm6()),
            0x4001 => return self.c_li(c.rd(), c.c_imm6()),
            0x6001 => return self.c_lui(c.rdn2(), c.c_nzimm18()),
            0xa001 => return self.c_j(c.c_imm12()),
            0xc001 => return self.c_beqz(c.rs1p(), c.c_bimm9()),
            0xe001 => return self.c_bnez(c.rs1p(), c.c_bimm9()),
            0x4002 => return self.c_lwsp(c.rdn0(), c.c_uimm8sp()),
            0xc002 => return self.c_swsp(c.c_rs2(), c.c_uimm8sp_s()),
            0x2001 => return self.c_jal(c.c_imm12()),
            0x0002 => return self.c_slli(c.rdrs1n0(), c.c_nzuimm6()),
            _ => {}
        }
        self.illegal(code)
    }
}

// End of auto-generated code.

#[cfg(test)]
mod test {
    use crate::cpu::{Rv32c, Rv32f, Rv32i, Rv32m};
    use crate::reg::Reg;

    // Base RV32I - generated by parse.py in riscv-opcodes.
    const MATCH_ADD: u32 = 0x33;
    const MASK_ADD: u32 = 0xfe00707f;
    const MATCH_ADDI: u32 = 0x13;
    const MASK_ADDI: u32 = 0x707f;
    const MATCH_AND: u32 = 0x7033;
    const MASK_AND: u32 = 0xfe00707f;
    const MATCH_ANDI: u32 = 0x7013;
    const MASK_ANDI: u32 = 0x707f;
    const MATCH_AUIPC: u32 = 0x17;
    const MASK_AUIPC: u32 = 0x7f;
    const MATCH_BEQ: u32 = 0x63;
    const MASK_BEQ: u32 = 0x707f;
    const MATCH_BGE: u32 = 0x5063;
    const MASK_BGE: u32 = 0x707f;
    const MATCH_BGEU: u32 = 0x7063;
    const MASK_BGEU: u32 = 0x707f;
    const MATCH_BLT: u32 = 0x4063;
    const MASK_BLT: u32 = 0x707f;
    const MATCH_BLTU: u32 = 0x6063;
    const MASK_BLTU: u32 = 0x707f;
    const MATCH_BNE: u32 = 0x1063;
    const MASK_BNE: u32 = 0x707f;
    const MATCH_EBREAK: u32 = 0x100073;
    const MASK_EBREAK: u32 = 0xffffffff;
    const MATCH_ECALL: u32 = 0x73;
    const MASK_ECALL: u32 = 0xffffffff;
    const MATCH_FENCE: u32 = 0xf;
    const MASK_FENCE: u32 = 0x707f;
    const MATCH_JAL: u32 = 0x6f;
    const MASK_JAL: u32 = 0x7f;
    const MATCH_JALR: u32 = 0x67;
    const MASK_JALR: u32 = 0x707f;
    const MATCH_LB: u32 = 0x3;
    const MASK_LB: u32 = 0x707f;
    const MATCH_LBU: u32 = 0x4003;
    const MASK_LBU: u32 = 0x707f;
    const MATCH_LH: u32 = 0x1003;
    const MASK_LH: u32 = 0x707f;
    const MATCH_LHU: u32 = 0x5003;
    const MASK_LHU: u32 = 0x707f;
    const MATCH_LUI: u32 = 0x37;
    const MASK_LUI: u32 = 0x7f;
    const MATCH_LW: u32 = 0x2003;
    const MASK_LW: u32 = 0x707f;
    const MATCH_OR: u32 = 0x6033;
    const MASK_OR: u32 = 0xfe00707f;
    const MATCH_ORI: u32 = 0x6013;
    const MASK_ORI: u32 = 0x707f;
    const MATCH_SB: u32 = 0x23;
    const MASK_SB: u32 = 0x707f;
    const MATCH_SH: u32 = 0x1023;
    const MASK_SH: u32 = 0x707f;
    const MATCH_SLL: u32 = 0x1033;
    const MASK_SLL: u32 = 0xfe00707f;
    const MATCH_SLLI: u32 = 0x1013;
    const MASK_SLLI: u32 = 0xfe00707f;
    const MATCH_SLT: u32 = 0x2033;
    const MASK_SLT: u32 = 0xfe00707f;
    const MATCH_SLTI: u32 = 0x2013;
    const MASK_SLTI: u32 = 0x707f;
    const MATCH_SLTIU: u32 = 0x3013;
    const MASK_SLTIU: u32 = 0x707f;
    const MATCH_SLTU: u32 = 0x3033;
    const MASK_SLTU: u32 = 0xfe00707f;
    const MATCH_SRA: u32 = 0x40005033;
    const MASK_SRA: u32 = 0xfe00707f;
    const MATCH_SRAI: u32 = 0x40005013;
    const MASK_SRAI: u32 = 0xfe00707f;
    const MATCH_SRL: u32 = 0x5033;
    const MASK_SRL: u32 = 0xfe00707f;
    const MATCH_SRLI: u32 = 0x5013;
    const MASK_SRLI: u32 = 0xfe00707f;
    const MATCH_SUB: u32 = 0x40000033;
    const MASK_SUB: u32 = 0xfe00707f;
    const MATCH_SW: u32 = 0x2023;
    const MASK_SW: u32 = 0x707f;
    const MATCH_XOR: u32 = 0x4033;
    const MASK_XOR: u32 = 0xfe00707f;
    const MATCH_XORI: u32 = 0x4013;
    const MASK_XORI: u32 = 0x707f;

    // 'M' extension - generated by parse.py in riscv-opcodes.
    const MATCH_DIV: u32 = 0x2004033;
    const MASK_DIV: u32 = 0xfe00707f;
    const MATCH_DIVU: u32 = 0x2005033;
    const MASK_DIVU: u32 = 0xfe00707f;
    const MATCH_MUL: u32 = 0x2000033;
    const MASK_MUL: u32 = 0xfe00707f;
    const MATCH_MULH: u32 = 0x2001033;
    const MASK_MULH: u32 = 0xfe00707f;
    const MATCH_MULHSU: u32 = 0x2002033;
    const MASK_MULHSU: u32 = 0xfe00707f;
    const MATCH_MULHU: u32 = 0x2003033;
    const MASK_MULHU: u32 = 0xfe00707f;
    const MATCH_REM: u32 = 0x2006033;
    const MASK_REM: u32 = 0xfe00707f;
    const MATCH_REMU: u32 = 0x2007033;
    const MASK_REMU: u32 = 0xfe00707f;

    // 'C' extension - generated by parse.py in riscv-opcodes.
    const MATCH_C_ADD: u32 = 0x9002;
    const MASK_C_ADD: u32 = 0xf003;
    const MATCH_C_ADDI: u32 = 0x1;
    const MASK_C_ADDI: u32 = 0xe003;
    const MATCH_C_ADDI16SP: u32 = 0x6101;
    const MASK_C_ADDI16SP: u32 = 0xef83;
    const MATCH_C_ADDI4SPN: u32 = 0x0;
    const MASK_C_ADDI4SPN: u32 = 0xe003;
    const MATCH_C_AND: u32 = 0x8c61;
    const MASK_C_AND: u32 = 0xfc63;
    const MATCH_C_ANDI: u32 = 0x8801;
    const MASK_C_ANDI: u32 = 0xec03;
    const MATCH_C_BEQZ: u32 = 0xc001;
    const MASK_C_BEQZ: u32 = 0xe003;
    const MATCH_C_BNEZ: u32 = 0xe001;
    const MASK_C_BNEZ: u32 = 0xe003;
    const MATCH_C_EBREAK: u32 = 0x9002;
    const MASK_C_EBREAK: u32 = 0xffff;
    const MATCH_C_J: u32 = 0xa001;
    const MASK_C_J: u32 = 0xe003;
    const MATCH_C_JAL: u32 = 0x2001;
    const MASK_C_JAL: u32 = 0xe003;
    const MATCH_C_JALR: u32 = 0x9002;
    const MASK_C_JALR: u32 = 0xf07f;
    const MATCH_C_JR: u32 = 0x8002;
    const MASK_C_JR: u32 = 0xf07f;
    const MATCH_C_LI: u32 = 0x4001;
    const MASK_C_LI: u32 = 0xe003;
    const MATCH_C_LUI: u32 = 0x6001;
    const MASK_C_LUI: u32 = 0xe003;
    const MATCH_C_LW: u32 = 0x4000;
    const MASK_C_LW: u32 = 0xe003;
    const MATCH_C_LWSP: u32 = 0x4002;
    const MASK_C_LWSP: u32 = 0xe003;
    const MATCH_C_MV: u32 = 0x8002;
    const MASK_C_MV: u32 = 0xf003;
    const MATCH_C_NOP: u32 = 0x1;
    const MASK_C_NOP: u32 = 0xef83;
    const MATCH_C_OR: u32 = 0x8c41;
    const MASK_C_OR: u32 = 0xfc63;
    const MATCH_C_SLLI: u32 = 0x2;
    const MASK_C_SLLI: u32 = 0xf003;
    const MATCH_C_SRAI: u32 = 0x8401;
    const MASK_C_SRAI: u32 = 0xfc03;
    const MATCH_C_SRLI: u32 = 0x8001;
    const MASK_C_SRLI: u32 = 0xfc03;
    const MATCH_C_SUB: u32 = 0x8c01;
    const MASK_C_SUB: u32 = 0xfc63;
    const MATCH_C_SW: u32 = 0xc000;
    const MASK_C_SW: u32 = 0xe003;
    const MATCH_C_SWSP: u32 = 0xc002;
    const MASK_C_SWSP: u32 = 0xe003;
    const MATCH_C_XOR: u32 = 0x8c21;
    const MASK_C_XOR: u32 = 0xfc63;

    // 'F' extension - Generated by parse.py in riscv-opcodes.
    const MATCH_FADD_S: u32 = 0x53;
    const MASK_FADD_S: u32 = 0xfe00007f;
    const MATCH_FCLASS_S: u32 = 0xe0001053;
    const MASK_FCLASS_S: u32 = 0xfff0707f;
    const MATCH_FCVT_S_W: u32 = 0xd0000053;
    const MASK_FCVT_S_W: u32 = 0xfff0007f;
    const MATCH_FCVT_S_WU: u32 = 0xd0100053;
    const MASK_FCVT_S_WU: u32 = 0xfff0007f;
    const MATCH_FCVT_W_S: u32 = 0xc0000053;
    const MASK_FCVT_W_S: u32 = 0xfff0007f;
    const MATCH_FCVT_WU_S: u32 = 0xc0100053;
    const MASK_FCVT_WU_S: u32 = 0xfff0007f;
    const MATCH_FDIV_S: u32 = 0x18000053;
    const MASK_FDIV_S: u32 = 0xfe00007f;
    const MATCH_FEQ_S: u32 = 0xa0002053;
    const MASK_FEQ_S: u32 = 0xfe00707f;
    const MATCH_FLE_S: u32 = 0xa0000053;
    const MASK_FLE_S: u32 = 0xfe00707f;
    const MATCH_FLT_S: u32 = 0xa0001053;
    const MASK_FLT_S: u32 = 0xfe00707f;
    const MATCH_FLW: u32 = 0x2007;
    const MASK_FLW: u32 = 0x707f;
    const MATCH_FMADD_S: u32 = 0x43;
    const MASK_FMADD_S: u32 = 0x600007f;
    const MATCH_FMAX_S: u32 = 0x28001053;
    const MASK_FMAX_S: u32 = 0xfe00707f;
    const MATCH_FMIN_S: u32 = 0x28000053;
    const MASK_FMIN_S: u32 = 0xfe00707f;
    const MATCH_FMSUB_S: u32 = 0x47;
    const MASK_FMSUB_S: u32 = 0x600007f;
    const MATCH_FMUL_S: u32 = 0x10000053;
    const MASK_FMUL_S: u32 = 0xfe00007f;
    const MATCH_FMV_W_X: u32 = 0xf0000053;
    const MASK_FMV_W_X: u32 = 0xfff0707f;
    const MATCH_FMV_X_W: u32 = 0xe0000053;
    const MASK_FMV_X_W: u32 = 0xfff0707f;
    const MATCH_FNMADD_S: u32 = 0x4f;
    const MASK_FNMADD_S: u32 = 0x600007f;
    const MATCH_FNMSUB_S: u32 = 0x4b;
    const MASK_FNMSUB_S: u32 = 0x600007f;
    const MATCH_FSGNJ_S: u32 = 0x20000053;
    const MASK_FSGNJ_S: u32 = 0xfe00707f;
    const MATCH_FSGNJN_S: u32 = 0x20001053;
    const MASK_FSGNJN_S: u32 = 0xfe00707f;
    const MATCH_FSGNJX_S: u32 = 0x20002053;
    const MASK_FSGNJX_S: u32 = 0xfe00707f;
    const MATCH_FSQRT_S: u32 = 0x58000053;
    const MASK_FSQRT_S: u32 = 0xfff0007f;
    const MATCH_FSUB_S: u32 = 0x8000053;
    const MASK_FSUB_S: u32 = 0xfe00007f;
    const MATCH_FSW: u32 = 0x2027;
    const MASK_FSW: u32 = 0x707f;

    #[inline]
    fn enc(pattern: u32, mask: u32) -> u32 {
        !mask | pattern
    }

    struct Checker;

    impl Rv32i for Checker {
        type Item = &'static str;

        fn illegal(&mut self, _ins: u32) -> Self::Item {
            "illegal"
        }

        fn beq(&mut self, _rs1: Reg, _rs2: Reg, _bimm: u32) -> Self::Item {
            "beq"
        }

        fn bne(&mut self, _rs1: Reg, _rs2: Reg, _bimm: u32) -> Self::Item {
            "bne"
        }

        fn blt(&mut self, _rs1: Reg, _rs2: Reg, _bimm: u32) -> Self::Item {
            "blt"
        }

        fn bge(&mut self, _rs1: Reg, _rs2: Reg, _bimm: u32) -> Self::Item {
            "bge"
        }

        fn bltu(&mut self, _rs1: Reg, _rs2: Reg, _bimm: u32) -> Self::Item {
            "bltu"
        }

        fn bgeu(&mut self, _rs1: Reg, _rs2: Reg, _bimm: u32) -> Self::Item {
            "bgeu"
        }

        fn lb(&mut self, _rd: Reg, _rs1: Reg, _iimm: u32) -> Self::Item {
            "lb"
        }

        fn lh(&mut self, _rd: Reg, _rs1: Reg, _iimm: u32) -> Self::Item {
            "lh"
        }

        fn lw(&mut self, _rd: Reg, _rs1: Reg, _iimm: u32) -> Self::Item {
            "lw"
        }

        fn lbu(&mut self, _rd: Reg, _rs1: Reg, _iimm: u32) -> Self::Item {
            "lbu"
        }

        fn lhu(&mut self, _rd: Reg, _rs1: Reg, _iimm: u32) -> Self::Item {
            "lhu"
        }

        fn addi(&mut self, _rd: Reg, _rs1: Reg, _iimm: u32) -> Self::Item {
            "addi"
        }

        fn slti(&mut self, _rd: Reg, _rs1: Reg, _iimm: u32) -> Self::Item {
            "slti"
        }

        fn sltiu(&mut self, _rd: Reg, _rs1: Reg, _iimm: u32) -> Self::Item {
            "sltiu"
        }

        fn xori(&mut self, _rd: Reg, _rs1: Reg, _iimm: u32) -> Self::Item {
            "xori"
        }

        fn ori(&mut self, _rd: Reg, _rs1: Reg, _iimm: u32) -> Self::Item {
            "ori"
        }

        fn andi(&mut self, _rd: Reg, _rs1: Reg, _iimm: u32) -> Self::Item {
            "andi"
        }

        fn jalr(&mut self, _rd: Reg, _rs1: Reg, _iimm: u32) -> Self::Item {
            "jalr"
        }

        fn sb(&mut self, _rs1: Reg, _rs2: Reg, _simm: u32) -> Self::Item {
            "sb"
        }

        fn sh(&mut self, _rs1: Reg, _rs2: Reg, _simm: u32) -> Self::Item {
            "sh"
        }

        fn sw(&mut self, _rs1: Reg, _rs2: Reg, _simm: u32) -> Self::Item {
            "sw"
        }

        fn auipc(&mut self, _rd: Reg, _uimm: u32) -> Self::Item {
            "auipc"
        }

        fn lui(&mut self, _rd: Reg, _uimm: u32) -> Self::Item {
            "lui"
        }

        fn jal(&mut self, _rd: Reg, _jimm: u32) -> Self::Item {
            "jal"
        }

        fn add(&mut self, _rd: Reg, _rs1: Reg, _rs2: Reg) -> Self::Item {
            "add"
        }

        fn sub(&mut self, _rd: Reg, _rs1: Reg, _rs2: Reg) -> Self::Item {
            "sub"
        }

        fn sll(&mut self, _rd: Reg, _rs1: Reg, _rs2: Reg) -> Self::Item {
            "sll"
        }

        fn slt(&mut self, _rd: Reg, _rs1: Reg, _rs2: Reg) -> Self::Item {
            "slt"
        }

        fn sltu(&mut self, _rd: Reg, _rs1: Reg, _rs2: Reg) -> Self::Item {
            "sltu"
        }

        fn xor(&mut self, _rd: Reg, _rs1: Reg, _rs2: Reg) -> Self::Item {
            "xor"
        }

        fn srl(&mut self, _rd: Reg, _rs1: Reg, _rs2: Reg) -> Self::Item {
            "srl"
        }

        fn sra(&mut self, _rd: Reg, _rs1: Reg, _rs2: Reg) -> Self::Item {
            "sra"
        }

        fn or(&mut self, _rd: Reg, _rs1: Reg, _rs2: Reg) -> Self::Item {
            "or"
        }

        fn and(&mut self, _rd: Reg, _rs1: Reg, _rs2: Reg) -> Self::Item {
            "and"
        }

        fn slli(&mut self, _rd: Reg, _rs1: Reg, _shamt: u32) -> Self::Item {
            "slli"
        }

        fn srli(&mut self, _rd: Reg, _rs1: Reg, _shamt: u32) -> Self::Item {
            "srli"
        }

        fn srai(&mut self, _rd: Reg, _rs1: Reg, _shamt: u32) -> Self::Item {
            "srai"
        }

        fn fence(&mut self, _fm: u32, _rd: Reg, _rs1: Reg) -> Self::Item {
            "fence"
        }

        fn ecall(&mut self) -> Self::Item {
            "ecall"
        }

        fn ebreak(&mut self) -> Self::Item {
            "ebreak"
        }
    }

    #[test]
    fn dispatch_rv32i() {
        use super::Rv32iDispatcher;

        let mut c = Checker {};
        assert_eq!("add", c.dispatch(enc(MATCH_ADD, MASK_ADD)));
        assert_eq!("addi", c.dispatch(enc(MATCH_ADDI, MASK_ADDI)));
        assert_eq!("and", c.dispatch(enc(MATCH_AND, MASK_AND)));
        assert_eq!("andi", c.dispatch(enc(MATCH_ANDI, MASK_ANDI)));
        assert_eq!("auipc", c.dispatch(enc(MATCH_AUIPC, MASK_AUIPC)));
        assert_eq!("beq", c.dispatch(enc(MATCH_BEQ, MASK_BEQ)));
        assert_eq!("bge", c.dispatch(enc(MATCH_BGE, MASK_BGE)));
        assert_eq!("bgeu", c.dispatch(enc(MATCH_BGEU, MASK_BGEU)));
        assert_eq!("blt", c.dispatch(enc(MATCH_BLT, MASK_BLT)));
        assert_eq!("bltu", c.dispatch(enc(MATCH_BLTU, MASK_BLTU)));
        assert_eq!("bne", c.dispatch(enc(MATCH_BNE, MASK_BNE)));
        assert_eq!("ebreak", c.dispatch(enc(MATCH_EBREAK, MASK_EBREAK)));
        assert_eq!("ecall", c.dispatch(enc(MATCH_ECALL, MASK_ECALL)));
        assert_eq!("fence", c.dispatch(enc(MATCH_FENCE, MASK_FENCE)));
        assert_eq!("jal", c.dispatch(enc(MATCH_JAL, MASK_JAL)));
        assert_eq!("jalr", c.dispatch(enc(MATCH_JALR, MASK_JALR)));
        assert_eq!("lb", c.dispatch(enc(MATCH_LB, MASK_LB)));
        assert_eq!("lbu", c.dispatch(enc(MATCH_LBU, MASK_LBU)));
        assert_eq!("lh", c.dispatch(enc(MATCH_LH, MASK_LH)));
        assert_eq!("lhu", c.dispatch(enc(MATCH_LHU, MASK_LHU)));
        assert_eq!("lui", c.dispatch(enc(MATCH_LUI, MASK_LUI)));
        assert_eq!("lw", c.dispatch(enc(MATCH_LW, MASK_LW)));
        assert_eq!("or", c.dispatch(enc(MATCH_OR, MASK_OR)));
        assert_eq!("ori", c.dispatch(enc(MATCH_ORI, MASK_ORI)));
        assert_eq!("sb", c.dispatch(enc(MATCH_SB, MASK_SB)));
        assert_eq!("sh", c.dispatch(enc(MATCH_SH, MASK_SH)));
        assert_eq!("sll", c.dispatch(enc(MATCH_SLL, MASK_SLL)));
        assert_eq!("slli", c.dispatch(enc(MATCH_SLLI, MASK_SLLI)));
        assert_eq!("slt", c.dispatch(enc(MATCH_SLT, MASK_SLT)));
        assert_eq!("slti", c.dispatch(enc(MATCH_SLTI, MASK_SLTI)));
        assert_eq!("sltiu", c.dispatch(enc(MATCH_SLTIU, MASK_SLTIU)));
        assert_eq!("sltu", c.dispatch(enc(MATCH_SLTU, MASK_SLTU)));
        assert_eq!("sra", c.dispatch(enc(MATCH_SRA, MASK_SRA)));
        assert_eq!("srai", c.dispatch(enc(MATCH_SRAI, MASK_SRAI)));
        assert_eq!("srl", c.dispatch(enc(MATCH_SRL, MASK_SRL)));
        assert_eq!("srli", c.dispatch(enc(MATCH_SRLI, MASK_SRLI)));
        assert_eq!("sub", c.dispatch(enc(MATCH_SUB, MASK_SUB)));
        assert_eq!("sw", c.dispatch(enc(MATCH_SW, MASK_SW)));
        assert_eq!("xor", c.dispatch(enc(MATCH_XOR, MASK_XOR)));
        assert_eq!("xori", c.dispatch(enc(MATCH_XORI, MASK_XORI)));
    }

    impl Rv32m for Checker {
        type Item = &'static str;

        fn mul(&mut self, _rd: Reg, _rs1: Reg, _rs2: Reg) -> Self::Item {
            "mul"
        }

        fn mulh(&mut self, _rd: Reg, _rs1: Reg, _rs2: Reg) -> Self::Item {
            "mulh"
        }

        fn mulhsu(&mut self, _rd: Reg, _rs1: Reg, _rs2: Reg) -> Self::Item {
            "mulhsu"
        }

        fn mulhu(&mut self, _rd: Reg, _rs1: Reg, _rs2: Reg) -> Self::Item {
            "mulhu"
        }

        fn div(&mut self, _rd: Reg, _rs1: Reg, _rs2: Reg) -> Self::Item {
            "div"
        }

        fn divu(&mut self, _rd: Reg, _rs1: Reg, _rs2: Reg) -> Self::Item {
            "divu"
        }

        fn rem(&mut self, _rd: Reg, _rs1: Reg, _rs2: Reg) -> Self::Item {
            "rem"
        }

        fn remu(&mut self, _rd: Reg, _rs1: Reg, _rs2: Reg) -> Self::Item {
            "remu"
        }
    }

    #[test]
    fn dispatch_rv32im() {
        use super::Rv32imDispatcher;

        let mut c = Checker {};
        assert_eq!("div", c.dispatch(enc(MATCH_DIV, MASK_DIV)));
        assert_eq!("divu", c.dispatch(enc(MATCH_DIVU, MASK_DIVU)));
        assert_eq!("mul", c.dispatch(enc(MATCH_MUL, MASK_MUL)));
        assert_eq!("mulh", c.dispatch(enc(MATCH_MULH, MASK_MULH)));
        assert_eq!("mulhsu", c.dispatch(enc(MATCH_MULHSU, MASK_MULHSU)));
        assert_eq!("mulhu", c.dispatch(enc(MATCH_MULHU, MASK_MULHU)));
        assert_eq!("rem", c.dispatch(enc(MATCH_REM, MASK_REM)));
        assert_eq!("remu", c.dispatch(enc(MATCH_REMU, MASK_REMU)));
    }

    impl Rv32c for Checker {
        type Item = &'static str;

        fn c_addi4spn(&mut self, _rdp: Reg, _imm: u32) -> Self::Item {
            "c.addi4spn"
        }

        fn c_lw(&mut self, _rdp: Reg, _rs1p: Reg, _imm: u32) -> Self::Item {
            "c.lw"
        }

        fn c_sw(&mut self, _rs1p: Reg, _rs2p: Reg, _imm: u32) -> Self::Item {
            "c.sw"
        }

        fn c_sub(&mut self, _rdrs1p: Reg, _rs2p: Reg) -> Self::Item {
            "c.sub"
        }

        fn c_xor(&mut self, _rdrs1p: Reg, _rs2p: Reg) -> Self::Item {
            "c.xor"
        }

        fn c_or(&mut self, _rdrs1p: Reg, _rs2p: Reg) -> Self::Item {
            "c.or"
        }

        fn c_and(&mut self, _rdrs1p: Reg, _rs2p: Reg) -> Self::Item {
            "c.and"
        }

        fn c_nop(&mut self, _imm: u32) -> Self::Item {
            "c.nop"
        }

        fn c_addi16sp(&mut self, _imm: u32) -> Self::Item {
            "c.addi16sp"
        }

        fn c_andi(&mut self, _rsrs1p: Reg, _imm: u32) -> Self::Item {
            "c.andi"
        }

        fn c_addi(&mut self, _rdrs1n0: Reg, _imm: u32) -> Self::Item {
            "c.addi"
        }

        fn c_li(&mut self, _rd: Reg, _imm: u32) -> Self::Item {
            "c.li"
        }

        fn c_lui(&mut self, _rdn2: Reg, _imm: u32) -> Self::Item {
            "c.lui"
        }

        fn c_j(&mut self, _imm: u32) -> Self::Item {
            "c.j"
        }

        fn c_beqz(&mut self, _rs1p: Reg, _imm: u32) -> Self::Item {
            "c.beqz"
        }

        fn c_bnez(&mut self, _rs1p: Reg, _imm: u32) -> Self::Item {
            "c.bnez"
        }

        fn c_jr(&mut self, _rs1n0: Reg) -> Self::Item {
            "c.jr"
        }

        fn c_jalr(&mut self, _rs1n0: Reg) -> Self::Item {
            "c.jalr"
        }

        fn c_ebreak(&mut self) -> Self::Item {
            "c.ebreak"
        }

        fn c_mv(&mut self, _rd: Reg, _rs2n0: Reg) -> Self::Item {
            "c.mv"
        }

        fn c_add(&mut self, _rdrs1: Reg, _rs2n0: Reg) -> Self::Item {
            "c.add"
        }

        fn c_lwsp(&mut self, _rdn0: Reg, _imm: u32) -> Self::Item {
            "c.lwsp"
        }

        fn c_swsp(&mut self, _rs2: Reg, _imm: u32) -> Self::Item {
            "c.swsp"
        }

        fn c_jal(&mut self, _imm: u32) -> Self::Item {
            "c.jal"
        }

        fn c_srli(&mut self, _rdrs1p: Reg, _imm: u32) -> Self::Item {
            "c.srli"
        }

        fn c_srai(&mut self, _rdrs1p: Reg, _imm: u32) -> Self::Item {
            "c.srai"
        }

        fn c_slli(&mut self, _rdrs1n0: Reg, _imm: u32) -> Self::Item {
            "c.slli"
        }
    }

    #[test]
    fn dispatch_rv32ic() {
        use super::Rv32icDispatcher;

        let mut c = Checker {};
        assert_eq!("c.add", c.dispatch(enc(MATCH_C_ADD, MASK_C_ADD)));
        assert_eq!("c.addi", c.dispatch(enc(MATCH_C_ADDI, MASK_C_ADDI)));
        assert_eq!(
            "c.addi16sp",
            c.dispatch(enc(MATCH_C_ADDI16SP, MASK_C_ADDI16SP))
        );
        assert_eq!(
            "c.addi4spn",
            c.dispatch(enc(MATCH_C_ADDI4SPN, MASK_C_ADDI4SPN))
        );
        assert_eq!("c.and", c.dispatch(enc(MATCH_C_AND, MASK_C_AND)));
        assert_eq!("c.andi", c.dispatch(enc(MATCH_C_ANDI, MASK_C_ANDI)));
        assert_eq!("c.beqz", c.dispatch(enc(MATCH_C_BEQZ, MASK_C_BEQZ)));
        assert_eq!("c.bnez", c.dispatch(enc(MATCH_C_BNEZ, MASK_C_BNEZ)));
        assert_eq!("c.ebreak", c.dispatch(enc(MATCH_C_EBREAK, MASK_C_EBREAK)));
        assert_eq!("c.j", c.dispatch(enc(MATCH_C_J, MASK_C_J)));
        assert_eq!("c.jal", c.dispatch(enc(MATCH_C_JAL, MASK_C_JAL)));
        assert_eq!("c.jalr", c.dispatch(enc(MATCH_C_JALR, MASK_C_JALR)));
        assert_eq!("c.jr", c.dispatch(enc(MATCH_C_JR, MASK_C_JR)));
        assert_eq!("c.li", c.dispatch(enc(MATCH_C_LI, MASK_C_LI)));
        assert_eq!("c.lui", c.dispatch(enc(MATCH_C_LUI, MASK_C_LUI)));
        assert_eq!("c.lw", c.dispatch(enc(MATCH_C_LW, MASK_C_LW)));
        assert_eq!("c.lwsp", c.dispatch(enc(MATCH_C_LWSP, MASK_C_LWSP)));
        assert_eq!("c.mv", c.dispatch(enc(MATCH_C_MV, MASK_C_MV)));
        assert_eq!("c.nop", c.dispatch(enc(MATCH_C_NOP, MASK_C_NOP)));
        assert_eq!("c.or", c.dispatch(enc(MATCH_C_OR, MASK_C_OR)));
        assert_eq!("c.slli", c.dispatch(enc(MATCH_C_SLLI, MASK_C_SLLI)));
        assert_eq!("c.srai", c.dispatch(enc(MATCH_C_SRAI, MASK_C_SRAI)));
        assert_eq!("c.srli", c.dispatch(enc(MATCH_C_SRLI, MASK_C_SRLI)));
        assert_eq!("c.sub", c.dispatch(enc(MATCH_C_SUB, MASK_C_SUB)));
        assert_eq!("c.sw", c.dispatch(enc(MATCH_C_SW, MASK_C_SW)));
        assert_eq!("c.swsp", c.dispatch(enc(MATCH_C_SWSP, MASK_C_SWSP)));
        assert_eq!("c.xor", c.dispatch(enc(MATCH_C_XOR, MASK_C_XOR)));
    }

    impl Rv32f for Checker {
        type Item = &'static str;

        fn flw(&mut self, _rd: Reg, _rs1: Reg, _iimm: u32) -> Self::Item {
            "flw"
        }

        fn fsw(&mut self, _rs1: Reg, _rs2: Reg, _simm: u32) -> Self::Item {
            "fsw"
        }

        fn fsqrt_s(&mut self, _rd: Reg, _rs1: Reg, _rm: u32) -> Self::Item {
            "fsqrt.s"
        }

        fn fcvt_w_s(&mut self, _rd: Reg, _rs1: Reg, _rm: u32) -> Self::Item {
            "fcvt.w.s"
        }

        fn fcvt_wu_s(&mut self, _rd: Reg, _rs1: Reg, _rm: u32) -> Self::Item {
            "fcvt.wu.s"
        }

        fn fcvt_s_w(&mut self, _rd: Reg, _rs1: Reg, _rm: u32) -> Self::Item {
            "fcvt.s.w"
        }

        fn fcvt_s_wu(&mut self, _rd: Reg, _rs1: Reg, _rm: u32) -> Self::Item {
            "fcvt.s.wu"
        }

        fn fadd_s(&mut self, _rd: Reg, _rs1: Reg, _rs2: Reg, _rm: u32) -> Self::Item {
            "fadd.s"
        }

        fn fsub_s(&mut self, _rd: Reg, _rs1: Reg, _rs2: Reg, _rm: u32) -> Self::Item {
            "fsub.s"
        }

        fn fmul_s(&mut self, _rd: Reg, _rs1: Reg, _rs2: Reg, _rm: u32) -> Self::Item {
            "fmul.s"
        }

        fn fdiv_s(&mut self, _rd: Reg, _rs1: Reg, _rs2: Reg, _rm: u32) -> Self::Item {
            "fdiv.s"
        }

        fn fmadd_s(&mut self, _rd: Reg, _rs1: Reg, _rs2: Reg, _rs3: Reg, _rm: u32) -> Self::Item {
            "fmadd.s"
        }

        fn fmsub_s(&mut self, _rd: Reg, _rs1: Reg, _rs2: Reg, _rs3: Reg, _rm: u32) -> Self::Item {
            "fmsub.s"
        }

        fn fnmsub_s(&mut self, _rd: Reg, _rs1: Reg, _rs2: Reg, _rs3: Reg, _rm: u32) -> Self::Item {
            "fnmsub.s"
        }

        fn fnmadd_s(&mut self, _rd: Reg, _rs1: Reg, _rs2: Reg, _rs3: Reg, _rm: u32) -> Self::Item {
            "fnmadd.s"
        }

        fn fmv_x_w(&mut self, _rd: Reg, _rs1: Reg) -> Self::Item {
            "fmv.x.w"
        }

        fn fmv_w_x(&mut self, _rd: Reg, _rs1: Reg) -> Self::Item {
            "fmv.w.x"
        }

        fn fclass_s(&mut self, _rd: Reg, _rs1: Reg) -> Self::Item {
            "fclass.s"
        }

        fn fsgnj_s(&mut self, _rd: Reg, _rs1: Reg, _rs2: Reg) -> Self::Item {
            "fsgnj.s"
        }

        fn fmin_s(&mut self, _rd: Reg, _rs1: Reg, _rs2: Reg) -> Self::Item {
            "fmin.s"
        }

        fn fle_s(&mut self, _rd: Reg, _rs1: Reg, _rs2: Reg) -> Self::Item {
            "fle.s"
        }

        fn fsgnjn_s(&mut self, _rd: Reg, _rs1: Reg, _rs2: Reg) -> Self::Item {
            "fsgnjn.s"
        }

        fn fmax_s(&mut self, _rd: Reg, _rs1: Reg, _rs2: Reg) -> Self::Item {
            "fmax.s"
        }

        fn flt_s(&mut self, _rd: Reg, _rs1: Reg, _rs2: Reg) -> Self::Item {
            "flt.s"
        }

        fn fsgnjx_s(&mut self, _rd: Reg, _rs1: Reg, _rs2: Reg) -> Self::Item {
            "fsgnjx.s"
        }

        fn feq_s(&mut self, _rd: Reg, _rs1: Reg, _rs2: Reg) -> Self::Item {
            "feq.s"
        }
    }

    #[test]
    fn dispatch_rv32imf() {
        use super::Rv32imfDispatcher;

        let mut c = Checker {};
        assert_eq!("fadd.s", c.dispatch(enc(MATCH_FADD_S, MASK_FADD_S)));
        assert_eq!("fclass.s", c.dispatch(enc(MATCH_FCLASS_S, MASK_FCLASS_S)));
        assert_eq!("fcvt.s.w", c.dispatch(enc(MATCH_FCVT_S_W, MASK_FCVT_S_W)));
        assert_eq!(
            "fcvt.s.wu",
            c.dispatch(enc(MATCH_FCVT_S_WU, MASK_FCVT_S_WU))
        );
        assert_eq!("fcvt.w.s", c.dispatch(enc(MATCH_FCVT_W_S, MASK_FCVT_W_S)));
        assert_eq!(
            "fcvt.wu.s",
            c.dispatch(enc(MATCH_FCVT_WU_S, MASK_FCVT_WU_S))
        );
        assert_eq!("fdiv.s", c.dispatch(enc(MATCH_FDIV_S, MASK_FDIV_S)));
        assert_eq!("feq.s", c.dispatch(enc(MATCH_FEQ_S, MASK_FEQ_S)));
        assert_eq!("fle.s", c.dispatch(enc(MATCH_FLE_S, MASK_FLE_S)));
        assert_eq!("flt.s", c.dispatch(enc(MATCH_FLT_S, MASK_FLT_S)));
        assert_eq!("flw", c.dispatch(enc(MATCH_FLW, MASK_FLW)));
        assert_eq!("fmadd.s", c.dispatch(enc(MATCH_FMADD_S, MASK_FMADD_S)));
        assert_eq!("fmax.s", c.dispatch(enc(MATCH_FMAX_S, MASK_FMAX_S)));
        assert_eq!("fmin.s", c.dispatch(enc(MATCH_FMIN_S, MASK_FMIN_S)));
        assert_eq!("fmsub.s", c.dispatch(enc(MATCH_FMSUB_S, MASK_FMSUB_S)));
        assert_eq!("fmul.s", c.dispatch(enc(MATCH_FMUL_S, MASK_FMUL_S)));
        assert_eq!("fmv.w.x", c.dispatch(enc(MATCH_FMV_W_X, MASK_FMV_W_X)));
        assert_eq!("fmv.x.w", c.dispatch(enc(MATCH_FMV_X_W, MASK_FMV_X_W)));
        assert_eq!("fnmadd.s", c.dispatch(enc(MATCH_FNMADD_S, MASK_FNMADD_S)));
        assert_eq!("fnmsub.s", c.dispatch(enc(MATCH_FNMSUB_S, MASK_FNMSUB_S)));
        assert_eq!("fsgnj.s", c.dispatch(enc(MATCH_FSGNJ_S, MASK_FSGNJ_S)));
        assert_eq!("fsgnjn.s", c.dispatch(enc(MATCH_FSGNJN_S, MASK_FSGNJN_S)));
        assert_eq!("fsgnjx.s", c.dispatch(enc(MATCH_FSGNJX_S, MASK_FSGNJX_S)));
        assert_eq!("fsqrt.s", c.dispatch(enc(MATCH_FSQRT_S, MASK_FSQRT_S)));
        assert_eq!("fsub.s", c.dispatch(enc(MATCH_FSUB_S, MASK_FSUB_S)));
        assert_eq!("fsw", c.dispatch(enc(MATCH_FSW, MASK_FSW)));
    }
}
